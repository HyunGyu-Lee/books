# Summary

* [Backend](content/backend/index.md) 
* [Frontend](content/frontend/index.md)
* [Architecture](content/architecture/index.md)
    * [DDD Start!](content/architecture/ddd-start!/index.md)
        * [1. 도메인 모델 시작](content/architecture/ddd-start!/1.md)
        * [2. 아키텍쳐 개요]()
        * [3. 애그리거트]()
        * [4. 리포지터리와 모델구현(JPA 중심)]()
        * [5. 리포지터리와 조회 기능(JPA 중심)]()
        * [6. 응용 서비스와 표현 영역]()
        * [7. 도메인 서비스]()
        * [8. 애그리거트 트랜잭션 관리]()
        * [9. 도메인 모델과 BOUNDED CONTEXT]()
        * [10. 이벤트]()
        * [11. CQRS]()
* [Better Developer](content/better-developer/index.md)
    * [읽기 좋은 코드가 좋은 코드다](content/better-developer/the-art-of-readable-code/index.md)
        * [1. 코드는 이해하기 쉬워야 한다.](content/better-developer/the-art-of-readable-code/index.md)
            * [1.1. 무엇이 코드를 '더 좋게' 만드는가?](content/better-developer/the-art-of-readable-code/1-1.md)
            * [1.2. 가독성의 기본정리](content/better-developer/the-art-of-readable-code/1-2.md)
            * [1.3. 분량이 적으면 항상 더 좋은가?](content/better-developer/the-art-of-readable-code/1-3.md)
            * [1.4. 이해를 위한 시간은 다른 목표와 충돌하는가?]()
            * [1.5. 어려운 부분]()
        * [2. 이름에 정보 담기]()
            * [2.1. 특정한 단어 고르기]()
            * [2.2. tmp나 retval 같은 보편적인 이름 피하기]()
            * [2.3. 추상적인 이름보다 구체적인 이름을 선호하라]()
            * [2.4. 추가적인 정보를 이름에 추가하기]()
            * [2.5. 이름은 얼마나 길어야 하는가?]()
            * [2.6. 이름 포메팅으로 의미를 전달하라]()
            * [2.7. 요약]()
        * [3. 오해할 수 없는 이름들]()
            * [3.1. 예: Filter()]()
            * [3.2. 예: Clip(text, length)]()
            * [3.3. 경계를 포함하는 한계값을 다룰 때는 min과 max를 사용하라]()
            * [3.4. 경계를 포함하는 범위에는 first와 last를 사용하라]()
            * [3.5. 경계를 포함하고/배제하는 범위에는 begin과 end를 사용하라]()
            * [3.6. 불리언 변수에 이름 붙이기]()
            * [3.7. 사용자의 기대에 부응하기]()
            * [3.8. 예: 이름을 짓기 위해서 복수의 후보를 평가하기]()
            * [3.9. 요약]()
        * [4. 미학]()
            * [4.1. 미학이 무슨 상관인가?]()
            * [4.2. 일관성과 간결성을 위해서 줄 바꿈을 재정렬하기]()
            * [4.3. 메소드를 활용하여 불규칙성을 정리하라]()
            * [4.4. 도움이 된다면 코드의 열을 맞춰라]()
            * [4.5. 의미 있는 순서를 선택하고 일관성 있게 사용하라]()
            * [4.6. 선언문을 블록으로 구성하라]()
            * [4.7. 코드를 '문단'으로 쪼개라]()
            * [4.8. 개인적인 스타일 대 일관성]()
            * [4.9. 요약]()
        * [5. 주석에 담아야 하는 대상]()
            * [5.1. 설명하지 말아야 하는 것]()
            * [5.2. 생각을 기록하라]()
            * [5.3. 코드를 읽는 사람의 입장이 되어라]()
            * [5.4. 마지막 고찰 - 글 쓰는 두려움을 떨쳐내라]()
            * [5.5. 요약]()
        * [6 명확하고 간결한 주석 달기]()
            * [6.1. 주석을 간결하게 하라]()
            * [6.2. 모호한 대명사는 피하라]()
            * [6.3. 엉터리 문장을 다듬어라]()
            * [6.4. 함수의 동작을 명확하게 설명하라]()
            * [6.5. 코너케이스를 설명해주는 입/출력 예를 사용하라]()
            * [6.6. 코드의 의도를 명시하라]()
            * [6.7. 이름을 가진 함수 파라미터 주석]()
            * [6.8. 정보 축약형 단어를 사용하라]()
            * [6.9. 요약]()
        * [7. 읽기 쉽게 흐름제어 만들기]()
            * [7.1. 조건문에서 인수의 순서]()
            * [7.2. if/else 블록의 순서]()
            * [7.3. (삼항 연산자로 알려진)?:를 이용하는 조건문 표현]()
            * [7.4. do/while 루프를 피하라]()
            * [7.5. 함수 중간에서 반환하기]()
            * [7.6. 악명 높은 goto]()
            * [7.7. 중첩을 최소화하기]()
            * [7.8. 실행 흐름을 따라올 수 있는가?]()
            * [7.9. 요약]()
        * [8. 거대한 표현을 잘게 쪼개기]()
            * [8.1. 설명 변수]()
            * [8.2. 요약 변수]()
            * [8.3. 드모르간의 법칙 사용하기]()
            * [8.4. 쇼트 서킷 논리 오용하기]()
            * [8.5. 예: 복잡한 논리와 씨름하기]()
            * [8.6. 거대한 구문 나누기]()
            * [8.7. 표현을 단순화하는 다른 창의적인 방법들]()
            * [8.8. 요약]()
        * [9. 변수와 가독성]()
            * [9.1. 변수 제거하기]()
            * [9.2. 변수의 범위를 좁혀라]()
            * [9.3. 값을 한 번만 할당하는 변수를 선호하라]()
            * [9.4. 마지막 예]()
            * [9.5. 요약]()
        * [10. 상관없는 하위문제 추출하기]()
            * [10.1. 소개를 위한 예: findClosestLocation()]()
            * [10.2. 순수한 유틸리티 코드]()
            * [10.3. 일반적인 목적의 코드]()
            * [10.4. 일반적인 목적을 가진 코드를 많이 만들어라]()
            * [10.5. 특정한 프로젝트를 위한 기능]()
            * [10.6. 기존의 인터페이스를 단순화하기]()
            * [10.7. 자신의 필요에 맞춰서 인터페이스의 형태를 바꾸기]()
            * [10.8. 지나치게 추출하기]()
            * [10.9. 요약]()
        * [11. 한 번에 하나씩]()
            * [11.1. 작업은 작을 수 있다]()
            * [11.2. 객체에서 값 추출하기]()
            * [11.3. 더 큰 예제]()
            * [11.4. 요약]()
        * [12. 생각을 코드로 만들기]()
            * [12.1. 논리를 명확하게 설명하기]()
            * [12.2. 라이브러리를 알면 도움이 된다]()
            * [12.3. 논리를 쉬운 말로 표현하는 방법을 더 큰 문제에 적용하기]()
            * [12.4. 요약]()
        * [13. 코드 분량 줄이기]()
            * [13.1. 그 기능을 구현하려고 애쓰지 마라 - 그럴 필요가 없다]()
            * [13.2. 요구사항에 질문을 던지고 질문을 잘게 나누어 분석하라]()
            * [13.3. 코드베이스를 작게 유지하기]()
            * [13.4. 자기 주변에 있는 라이브러리에 친숙해져라]()
            * [13.5. 예: 코딩 대신 유닉스 도구를 활용하기]()
            * [13.6. 요약]()
        * [14. 테스트와 가독성]()
            * [14.1. 읽거나 유지보수하기 쉽게 테스트를 만들어라]()
            * [14.2. 이 테스트는 어떤 점이 잘못되었을까?]()
            * [14.3. 이 테스트를 더 읽기 쉽게 만들기]()
            * [14.4. 읽기 편한 메시지 만들기]()
            * [14.5. 좋은 테스트 입력값의 선택]()
            * [14.6. 테스트 함수에 이름 붙이기]()
            * [14.7. 이 테스트 코드는 무엇이 잘못되었는가?]()
            * [14.8. 테스트에 친숙한 개발]()
            * [14.9. 지나친 테스트]()
            * [14.10. 요약]()
        * [15. '분/시간 카운터'를 설계하고 구현하기]()
            * [15.1. 문제]()
            * [15.2. 클래스 인터페이스 정의하기]()
            * [15.3. 시도1: 순진한 해결책]()
            * [15.4. 시도2: 컨베이어 벨트 설계]()
            * [15.5. 시도3: 시간-바구니 설계]()
            * [15.6. 3가지 해결책 비교하기]()
            * [15.7. 요약]()