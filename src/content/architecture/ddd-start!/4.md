# 4. 리포지터리와 모델 구현 (JPA 중심)

## JPA를 이용한 리포지터리 구현
#### 모듈 위치
- 리포지터리 인터페이스는 애그리거트와 같이 도메인 영역
- 리포지터리를 상세 기술로 구현한 클래스는 인프라스트럭쳐 영역
- 일부 패키지 구성 시 도메인 영역 내 `impl`을 사용하는 케이스가 있는데, 이는 그리 좋은 방법은 아니다. (인프라 요소는 인프라 영역에 있도록 하여 도메인의 인프라 의존을 낮춰야함)

#### 리포지터리 기본 기능 구현
- 리포지터리의 기본 기능은 `아이디로 애그리거트 조회`, `애그리거트 저장`
- 인터페이스는 애그리거트 루트를 기준으로 작성
- 리포지터리 인터페이스 예시 (도메인)
```java
public interface OrderRepository {
        public Order findById(OrderNo no);
        public void save(Order order);
} 
```
- JPA 리포지터리 구현체 예시 (인프라)
```java
@Repository
public class JpaOrderRepository implements OrderRepository {
        @PersistenceContext
        private EntityManager entityManager;

        @Override
        public Order findById(OrderNo id) {
            return entityManager.find(Order.class, id);
        }

        @Override
        public void save(Order order) {
            entityManager.persist(order);
        }
}
```
- JPA는 엔티티 값 변경 시 EntityManager가 flush 될 때 DB에 변경 사항이 반영되기 때문에 JPA 리포지터리 구현체에는 수정 메소드는 필요 없음
- 리포지터리 인터페이스의 조회 기능 정의 시 특정 필드로 조회 조건은 `findBy + 필드명`으로 하는게 일반적이다
```java
public interface OrderRepository {
        ...
        public List<Order> findByOrdererId(String ordererId, int startRow, int size);
} 
```
- 삭제기능은 `delete` 로 구현한다
```java
public interface OrderRepository {
        ...
        public void delete(Order order);
} 
```

#### 삭제 기능
- 삭제 요구사항이 있어도, 관리자 기능, 원복 등 여러 가지 이유로 실제 데이터를 삭제하지 않는 경우가 많다
- 이런 경우는 delete로 실제 삭제하기 보단 플래그를 활용

## 매핑 구현
#### 엔티티와 밸류 기본 매핑 구현
- 애그리거트 루트는 엔티티이므로 @Entity로 매핑
- 밸류는 @Embeddable, @Embedded로 매핑