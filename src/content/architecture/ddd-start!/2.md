# 2. 아키텍쳐 개요
## 도메인 영역의 주요 구성요소
도메인 영역은 DDD의 핵심인 도메인의 개념을 표현하고 구현한다.

- 엔티티 (ENTITY) : 도메인의 고유한 개념을 표현. 데이터와 관련 기능을 제공한다. 식별자와 라이프사이클을 가짐
- 밸류 (VALUE) : 도메인 모델에서 개념적으로 표현될 수 있는 속성. 식별자를 갖지 않고 주로 엔티티의 속성으로 사용됨
- 애그리거트 (AGGREGATE) : 여러 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것. 예를들어 `주문` 도메인은 주문 엔티티, 주문 항목 엔티티, 주문자 엔티티를 `주문` 애그리거트로 묶을수있음
- 리포지터리 (REPOSITORY) : 도메인 모델의 영속성을 처리. 대표적으로 DBMS에 저장, 조회하는 역할을 담당 
- 도메인 서비스 (DOMAIN SERVICE) : 특정 엔티티에 속하지 않은 도메인 로직을 제공. 예를들어 `할인 금액 계산` 기능은 상품, 쿠폰, 회원 등급 구매 금액 등 여러 엔티티와 밸류를 필요로 하는데 이럴 때 도메인 서비스를 통해 기능을 구현

#### 엔티티와 밸류
도메인 모델의 엔티티를 데이터베이스의 엔티티와 혼동하기 쉬운데, 둘은 중요한 차이점을 가지고 있다.

- DB 엔티티가 해당 개념의 데이터만 표현하는 반면 도메인 모델의 엔티티는 데이터 뿐만 아니라 ***도메인 기능을 함께 제공***
- DB 엔티티는 속성을 컬럼으로 밖에 표현할 수 없는데 도메인 모델의 엔티티는 밸류 타입을 사용할 수 있다.
  - 물론 DB에서도 관련 데이터를 묶어 별도 테이블로 분리할 수 있지만, 밸류 타입의 의미가 드러나지 않음
  - 밸류 타입에서 `변경`이란 밸류 객체 자체를 교체하는건데, 테이블 분리라면 값 변경일 뿐이고 이는 밸튜 타입 구현에 권장되는 방법인 `불변`에 위배됨

##### 데이터베이스 엔티티
> 데이타베이스 분야에서 개체 또는 엔티티(Entity)라고 하는 것은 데이타베이스에 표현하려고 하는 유형, 무형의 객체로서 서로 구별되는 것을 뜻한다. 이 개체는 현실 세계에 대해 사람이 생각하는 개념이나 정보의 단위로서 의미를 가지고 있다. 이것은 컴퓨터가 취급하는 화일의 레코드(record)에 대응한다. 이 개체는 그 단독으로 존재할 수 있으며, 정보로서의 역할을 한다. 하나의 개체는 하나 이상의 속성, 즉 애트리뷰트(attribute)로 구성되고 각 속성은 그 개체의 특성이나 상태를 기술해 준다.

#### 애그리거트
- 도메인이 커질수록 그를 표현하기 위해 엔티티와 밸류들이 많아진다. 
- 갯수야 중요한게 아니지만, 도메인 모델이 커지만 개발자는 전체 그림이 아닌 국지적인 부분에 집중하게 되는 경우가 발생한다.
- 도메인 모델 전체를 봐야 각 모델들의 관계, 하위 개별 모델들을 이해하기 쉽다.
- 애그리거트는 관련 객체를 하나로 묶어 도메인 모델을 상위 수준에서 이해하는 것을 돕는다.
- 애그리거트는 해당 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다. (애그리거트 루트)
  - 루트 엔티티에서 해당 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해 애그리거트가 구현해야할 도메인의 기능을 제공 (캡슐화)
  - 애그리거트 사용 측에서는 애그리거트 루트를 통해서만 해당 애그리커트 내 다른 밸류 객체에 접근 (책 60P)

> OOP에서 객체의 캡슐화와 애그리거트를 대조해 생각해보면 좀 더 이해가 쉽다.
>* 객체의 필드(속성), 메소드를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것을 말한다. => 애그리거트 루트이외 하위 엔티티 및 밸류는 노출하지 않음
>* 외부 객체는 객체 내부의 구조를 얻지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다. => 애그리거트 루트를 통해서만 도메인 기능 호출 가능
>* 필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 있다. => 애그리거트에 대한 조작을 의도한 방법만으로만 가능하게 함

#### 리포지터리
도메인 모델을 지속적으로 사용하려면 RDBMS, NoSQL, 파일 등 물리적 저장소에 저장(영속화)해야한다. 이를 위한 도메인 모델이 리포지터리이다.
- 엔티티와 밸류가 요구사항에서 도출되는 모델이라면, 리포지터리는 구현단계에서 도출되는 모델
- 주문 애그리거트를 위한 리포지터리 예시 
```java
public inferface OrderRepository {
    public Order findByNumber(OrderNumber number);
    public void save(Order order);
    public void delete(Order order);
}
```
- 위 예시에서 리포지터리에서 조작하는 도메인 모델의 단위가 주문 애그리거트 루트인 주문(Order)이다.
- 결과적으로 주문 엔티티는 주문 애그리거트에 속한 하위 도메인 모델들을 전부 포함하고 있기 때문에 주문 애그리거트 단위 처리가 된다.
- 주문 취소 기능을 제공하는 응용 서비스 예시
```java
public class CancelOrderService {
    private OrderRepository orderRepository;

    public void cancel(OrderNumber number) {
        // 리포지터리를 통해 도메인 객체 조회
        Order order = orderRepository.findByNumber(number);
        if (order == null) throw new NoOrderException(number);

        // 도메인 객체에 구현된 취소 기능 실행
        order.cancel();
    }
}
```
- 도메인 모델 관점에서 OrderRepository는 도메인 객체를 영속화 하는데 필요한 기능을 interface로 추상화한 것으로 고수준 모듈에 속함 (책 63p)
- 실제로 JPA 등으로 OrderRepositofy를 구현(implement)하는 클래스는 저수준 모듈로 인프라 영역에 속한다.
- 스프링 프레임워크를 사용한다면 아래와 같이 응용 서비스를 구성할 수 있다.
```java 
@Configuration
public class OrderServiceConfig {
    @Autowired
    private OrderRepository orderRepository;

    @Bean
    public CancelOrderService cancelOrderService() {
        return new CancelOrderService(orderRepository);
    }
}
```
```java
@Configuration
public class RepositoryConfig {
    @Bean
    public JpaOrderRepository orderRepository() {
        return new JpaOrderRepository();
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean emf() {
        ...
    }
}
```

- 응용 서비스와 리포지터리는 다음과 같은 이유로 밀접한 연관이 있다.
  - 응용 서비스는 필요한 도메인 객체를 구하거나 저장하기 위해 리포지터리를 사용
  - 응용 서비스는 트랜잭션을 관리하는데, 트랜잭션 처리는 리포지터리 구현 기술에 영향을 받음 
- 리포지터리의 사용 주체가 응용 서비스이기 때문에 리포지터리는 응용 서비스가 필요로 하는 메서드를 제공
  - 애그리거트를 저장하는 메서드 `void save(Aggregate agg)`
  - 애그리거트를 저장하는 메서드 `Aggregate findById(SomeId id)`
  - 필요에 따라 `delete`, `counts` 등 추가 기능 제공