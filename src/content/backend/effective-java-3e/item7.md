# 다 쓴 객체 참조를 해제하라
#### \#1. 가비지 컬렉터를 갖춘 언어에 대한 오해
- C, C++ 처럼 개발자가 메모리를 직접 관리해야하는 언어에 비해 자바와 같이 가비지 컬렉터를 갖춘 언어는 상당히 편리함을 제공한다.
- 하지만 그렇다고 메모리 관리에 전혀 신경쓰지 않아도 되는건 절대 아니다.
- 다음은 스택에서 pop 기능을 구현한 메소드이다.
```java
public Object pop() {
    if (size = 0) {
        throw new EmptyStackException();
    }
    return elements[--size];
}
```
- 위 코드는 단순히 보면 별 문제 없어보이지만, 더 이상 사용될 일이 없는 객체가 `elements[size]`에 계속 남아있게 되는 문제가 존재한다.
- 가비지 컬렉터는 불필요 객체를 회수 판단할 때, 해 당 객체뿐만이 아니라 해당 객체가 참조하는 모든 객체들의 참조를 회수하지 않기 떄문에 프로그램에서 사용하지 않더라도 메모리 상에는 계속 존재하게 된다. 이는 곧 `OOM`으로 이어진다.
- 해결법은 단순하다. `elements[size] = null`로 명시적으로 객체에 null을 할당하면 참조가 해제되고, 가비지 컬렉터가 회수해간다.
- 다 쓴 객체를 null 처리 하는 것은 추후에 실수로 이 객체를 다시 사용하려할때 `NPE`가 발생하여 버그를 미연에 방지해주는 역할도 하게된다.
- 하지만 모든 객체를 일일히 null처리하는 것은 그리 바람직한 것은 아니다.
- 일반적으로 변수의 범위를 가능한 한 적게 잡으면 이러한 일들이 자연스레 해결된다.

#### \#2. 캐시에서의 문제
- 캐시를 사용하다보면 종종 다 쓴 객체가 캐시에 상주하게 되는 경우가 발생한다.
- 보통의 Map 방식으로 구현된 캐시에서 키값이 Null이 되어 Map안에 Value를 꺼낼수 없는 상황인데 메모리에 상주한다면 분명 문제가 있는것이다.
- 이러한 경우에 WeakHashMap을 사용하면 해결할 수 있다. WeakHashMap은 key가 null이되면 해당 엔트리를 삭제해버리기 때문에 자연스레 가비지 컬렉터에 의해 회수된다.
- 이외의 경우는 보통 캐시 내 엔트리의 유효 기간을 정확히 지정할 수 없기때문에 오래된 엔티티의 가치를 떨어트리는 방법을 사용한다.
- 스케쥴러 등을 통해 사용되지 않았거나 오래된 엔트리를 정리해주거나, LinkedHashMap의 경우 removeEldestEntry를 활용해 처리할 수 있다.

#### \#3. 리스너 or 콜백
- 콜백도 사용 후 명확히 해지하지 않는다면 콜백 객체가 계속 쌓일수 있다.
- 이 경우 WeakReference를 이용하면 GC대상으로 명시할 수 있어 콜백이 계속 쌓이는 것을 방지할 수 있다.
