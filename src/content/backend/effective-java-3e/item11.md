# equals를 재정의하려거든 hashCode도 재정의하라
#### \#1. hashCode를 재정의해야하는 이유
- equals비교에 사용되는 정보가 변경되지 않았다면 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출하던 같은 값을 반환해야한다.
- equals가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야한다.
- 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 HashTable 성능이 좋아진다.
- 이러한 이유로 equals를 재정의하고 hashCode를 제대로 재정의하지 않으면 HashMap, HashSet같은 컬렉션 원소로 이용 시 문제가 발생한다.

#### \#2. 좋은 hashCode() 메소드 구현
1. int 형 변수 `result`를 선언한 후 값 `c`로 초기화 한다.
  - 이 때 `c`는 해당 객체의 첫 번째 핵심 필드의 해시코드
  - 핵심필드란 equals에 사용되는 필드
2. 해당 객체의 나머지 핵심필드에 대해 아래 작업을 수행해 값 `c`를 계산한다.
  - 기본 타입 필드라면 Type.hashCode 메소드를 사용해 해쉬코드를 계산한다.
  - 참조 타입 필드면서 이 필드가 equals에서 재귀적으로 equals를 호출하는 형태라면 hashCode를 재취적으로 호출한다.
  - 계산이 복잡해질 것 같으면 이 필드의 표준형을 만들어 표준형의 hashCode를 호출한다.
  - 필드의 값이 null이면 0을 사용한다. (다른 상수여도 무방하지만 일반적으로 0사용) 
  - 필드가 배열이라면 핵심 원소를 별도 필드로 간주하여 해시코드를 계산하고, 배열의 길이가 0이면 0값 사용
  - 배열 필드 전체가 핵심 원소라면 Arrays.hashCode 메소드를 사용한다.
3. **단계2**에서 계산된 값을 통해 result를 갱신한다.
```java
result = 31 * result + c
```

#### \#3. 참고사항
- equals에 사용하지 않는 필드는 해시코드 계산에 사용하면 안된다.
- 31을 곱하는 이유는 필드에 31이 곱해지므로써 순서에 따른 결과값이 달라져 해시 효과를 높이게 하기 위함이다.
  - 예를들어 String에 곱셉 없이 해시코드를 구현한다면 모든 아나그램의 해시코드가 같아진다.
- 곱할 숫자로 31을 선정한 이유는 31이 홀수이면서 소수이기 때문이다.
  - 숫자가 짝수이고 오버플로가 발생하면 값이 유실된다.
  - 소수를 곱하는 이유는 명확하진 않지만 정통적으로 그리 해왔다.
  - 또한 31은 `32 - 1`이다. 즉 `2^5 - 1`과 같고 어떤 수에 2를 곱하는것은 Shift연산으로 대신할 수 있기 때문에 보다 최적화된 방식으로 계산할 수 있다.
  - 요즘 VM은 이러한 최적화를 자동으로 처리한다고 한다.
- 객체가 불면이며 해시 계산에 비용이 많이 드는 경우 캐싱방식을 사용하는 것을 권장한다.
- 성능때문에 핵심필드를 해시 계산에서 제외하면 안된다. (해시 품질이 떨어짐)

#### \#4. 여러 해싱방식
- 위 소개한 방식은 충분히 간결하고, 빠르며 해시도 적절히 분배해준다.
- 만약 해시충돌이 최소화되야하는 방법이 필요된다면 구아바의 `Hashing`을 참고한다.
- Objects.hash 메소드는 필요한 인수를 배열로 받아 계산해주는 정적 메소드를 제공한다.
  - 이 방식의 경우 기본형이 박싱, 언박싱 되는 단계가 포함되기때문에 다소 느려질 수 있다.  